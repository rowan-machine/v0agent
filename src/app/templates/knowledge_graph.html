{% extends "base.html" %}
{% block content %}
<style>
  .graph-container {
    max-width: 100%;
    width: 100%;
    margin: 0 auto;
    padding: 1.5rem;
  }
  
  @media (min-width: 1800px) {
    .graph-container {
      padding: 2rem 3rem;
    }
  }

  .graph-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .graph-header h1 {
    font-size: 1.75rem;
    color: #1a1a1a;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .graph-actions {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    align-items: center;
    padding-right: 200px; /* Space for floating mode indicator */
    position: relative;
    z-index: 60; /* Above mode indicator */
  }

  .graph-btn {
    padding: 0.6rem 1.2rem;
    border: none;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    position: relative;
    z-index: 61;
  }

  .graph-btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
  }

  .graph-btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }

  .graph-btn-secondary {
    background: #f3f4f6;
    color: #374151;
    border: 1px solid #e5e7eb;
  }

  .graph-btn-secondary:hover {
    background: #e5e7eb;
  }

  .graph-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  /* Stats Cards */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .stat-card {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 1rem;
    text-align: center;
  }

  .stat-value {
    font-size: 1.75rem;
    font-weight: 700;
    color: #1a1a1a;
    line-height: 1;
  }

  .stat-label {
    font-size: 0.8rem;
    color: #6b7280;
    margin-top: 0.25rem;
  }

  .stat-card.data .stat-value { color: #3b82f6; }
  .stat-card.information .stat-value { color: #f59e0b; }
  .stat-card.knowledge .stat-value { color: #10b981; }
  .stat-card.wisdom .stat-value { color: #8b5cf6; }

  /* Mindmap Container */
  .mindmap-container {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 1.5rem;
  }

  .mindmap-header {
    padding: 1rem 1.25rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f9fafb;
  }

  .mindmap-header h2 {
    font-size: 1.1rem;
    color: #1a1a1a;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .mindmap-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .mindmap-controls select {
    padding: 0.4rem 0.8rem;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    font-size: 0.85rem;
    background: white;
  }

  #mindmapCanvas {
    width: 100%;
    height: 550px;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
  }

  /* Legend */
  .mindmap-legend {
    display: flex;
    gap: 1.5rem;
    padding: 0.75rem 1.25rem;
    border-top: 1px solid #e5e7eb;
    background: #f9fafb;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: #6b7280;
  }

  .legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
  }

  .legend-dot.data { background: #3b82f6; }
  .legend-dot.information { background: #f59e0b; }
  .legend-dot.knowledge { background: #10b981; }
  .legend-dot.wisdom { background: #8b5cf6; }
  .legend-dot.tag { background: #ec4899; }

  /* Panels Grid */
  .panels-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
  }

  @media (max-width: 900px) {
    .panels-grid {
      grid-template-columns: 1fr;
    }
  }

  .panel {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    overflow: hidden;
  }

  .panel-header {
    padding: 1rem 1.25rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .panel-header h3 {
    font-size: 1rem;
    color: #1a1a1a;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .panel-body {
    padding: 1rem;
    max-height: 350px;
    overflow-y: auto;
  }

  /* Tag Cloud */
  .tag-cloud {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .tag-item {
    padding: 0.35rem 0.75rem;
    background: #f3f4f6;
    border: 1px solid #e5e7eb;
    border-radius: 20px;
    font-size: 0.8rem;
    color: #374151;
    cursor: pointer;
    transition: all 0.2s;
  }

  .tag-item:hover {
    background: #667eea;
    color: white;
    border-color: #667eea;
  }

  .tag-item.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
    box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
  }

  .tag-item .tag-count {
    background: rgba(0,0,0,0.1);
    padding: 0.1rem 0.4rem;
    border-radius: 10px;
    font-size: 0.7rem;
    margin-left: 0.3rem;
  }

  /* Recent Items List */
  .recent-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .recent-item {
    padding: 0.75rem;
    background: #f9fafb;
    border-radius: 8px;
    border-left: 3px solid #e5e7eb;
    cursor: pointer;
    transition: all 0.2s;
  }

  .recent-item:hover {
    background: #f0f0ff;
    border-left-color: #667eea;
  }

  /* Dark mode overrides */
  [data-theme="dark"] .graph-header h1,
  [data-theme="dark"] .panel-header h3,
  [data-theme="dark"] .stat-label,
  [data-theme="dark"] .stat-value {
    color: #faf6f1 !important;
  }

  [data-theme="dark"] .panel,
  [data-theme="dark"] .stat-card,
  [data-theme="dark"] .mindmap-card {
    background: #2d2d2d !important;
    border-color: #4a4a4a !important;
  }

  [data-theme="dark"] .panel-header,
  [data-theme="dark"] .legend {
    border-color: #4a4a4a !important;
  }

  [data-theme="dark"] .tag-item {
    background: #3a3a3a !important;
    border-color: #4a4a4a !important;
    color: #c9b99a !important;
  }

  [data-theme="dark"] .tag-item:hover,
  [data-theme="dark"] .tag-item.active {
    background: #a0522d !important;
    border-color: #a0522d !important;
    color: #faf6f1 !important;
  }

  [data-theme="dark"] .tag-item.active {
    box-shadow: 0 0 0 2px rgba(160, 82, 45, 0.3);
  }

  [data-theme="dark"] .recent-item {
    background: #3a3a3a !important;
    border-color: #4a4a4a !important;
  }

  [data-theme="dark"] .recent-item:hover {
    background: #4a4a4a !important;
    border-left-color: #a0522d !important;
  }

  [data-theme="dark"] .recent-item-level,
  [data-theme="dark"] .recent-item-content {
    color: #c9b99a !important;
  }

  [data-theme="dark"] .graph-btn-secondary {
    background: #3a3a3a !important;
    border-color: #4a4a4a !important;
    color: #faf6f1 !important;
  }

  [data-theme="dark"] .legend-label {
    color: #c9b99a !important;
  }

  .recent-item.data { border-left-color: #3b82f6; }
  .recent-item.information { border-left-color: #f59e0b; }
  .recent-item.knowledge { border-left-color: #10b981; }
  .recent-item.wisdom { border-left-color: #8b5cf6; }

  .recent-item-level {
    font-size: 0.7rem;
    text-transform: uppercase;
    font-weight: 600;
    color: #6b7280;
    margin-bottom: 0.25rem;
  }

  .recent-item-content {
    font-size: 0.85rem;
    color: #374151;
    line-height: 1.4;
  }

  /* Toast */
  .graph-toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #10b981;
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 9999;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    animation: slideIn 0.3s ease;
  }

  .graph-toast.error { background: #ef4444; }
  .graph-toast.info { background: #3b82f6; }

  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  /* Spinner */
  .spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    display: inline-block;
  }

  .spinner.dark {
    border-color: rgba(0,0,0,0.1);
    border-top-color: #667eea;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Node tooltip */
  .node-tooltip {
    position: absolute;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 0.75rem 1rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    pointer-events: none;
    z-index: 1000;
    max-width: 300px;
    font-size: 0.85rem;
    display: none;
  }

  .node-tooltip-title {
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .node-tooltip-level {
    font-size: 0.7rem;
    text-transform: uppercase;
    color: #6b7280;
  }

  /* Last sync info */
  .last-sync {
    font-size: 0.8rem;
    color: #6b7280;
  }
</style>

<div class="graph-container">
  <div class="graph-header">
    <h1>üß† Knowledge Mindmap</h1>
    <div class="graph-actions">
      <span class="last-sync" id="lastSyncInfo">Never synced</span>
      <button class="graph-btn graph-btn-secondary" onclick="updateMindmap()" id="updateBtn">
        ‚ûï Update New Items
      </button>
      <button class="graph-btn graph-btn-primary" onclick="regenerateMindmap()" id="regenerateBtn">
        üîÑ Regenerate Full Map
      </button>
    </div>
  </div>

  <!-- Stats -->
  <div class="stats-grid">
    <div class="stat-card data">
      <div class="stat-value" id="dataCount">0</div>
      <div class="stat-label">Data</div>
    </div>
    <div class="stat-card information">
      <div class="stat-value" id="informationCount">0</div>
      <div class="stat-label">Information</div>
    </div>
    <div class="stat-card knowledge">
      <div class="stat-value" id="knowledgeCount">0</div>
      <div class="stat-label">Knowledge</div>
    </div>
    <div class="stat-card wisdom">
      <div class="stat-value" id="wisdomCount">0</div>
      <div class="stat-label">Wisdom</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="tagCount">0</div>
      <div class="stat-label">Tags</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="connectionCount">0</div>
      <div class="stat-label">Connections</div>
    </div>
  </div>

  <!-- Mindmap Visualization -->
  <div class="mindmap-container">
    <div class="mindmap-header">
      <h2>üï∏Ô∏è Knowledge Graph</h2>
      <div class="mindmap-controls">
        <button class="graph-btn graph-btn-secondary" onclick="zoomIn()" style="padding:0.4rem 0.6rem;">‚ûï</button>
        <button class="graph-btn graph-btn-secondary" onclick="zoomOut()" style="padding:0.4rem 0.6rem;">‚ûñ</button>
        <button class="graph-btn graph-btn-secondary" onclick="resetZoom()" style="padding:0.4rem 0.6rem;">‚Ü∫</button>
      </div>
    </div>
    <div id="mindmapCanvas"></div>
    <div class="mindmap-legend">
      <div class="legend-item"><span class="legend-dot data"></span> Data</div>
      <div class="legend-item"><span class="legend-dot information"></span> Information</div>
      <div class="legend-item"><span class="legend-dot knowledge"></span> Knowledge</div>
      <div class="legend-item"><span class="legend-dot wisdom"></span> Wisdom</div>
      <div class="legend-item"><span class="legend-dot tag"></span> Tags</div>
    </div>
  </div>

  <!-- Mindmap Synthesis Section -->
  <div class="mindmap-container" id="mindmapSynthesisSection" style="display: none; margin-top: 2rem;">
    <div class="mindmap-header">
      <h2>‚ú® Knowledge Synthesis</h2>
      <button class="graph-btn graph-btn-secondary" onclick="toggleSynthesisDetail()" style="font-size:0.8rem;">Show/Hide</button>
    </div>
    <div id="mindmapSynthesisContent" style="padding: 1.5rem; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border: 1px solid #e5e7eb; border-radius: 0.5rem; max-height: 400px; overflow-y: auto;">
      <p style="color: #9ca3af; text-align: center; padding: 2rem;">Loading synthesis...</p>
    </div>
  </div>

  <!-- Panels -->
  <div class="panels-grid">
    <!-- Tag Cloud Panel -->
    <div class="panel">
      <div class="panel-header">
        <h3>üè∑Ô∏è Tag Cloud</h3>
        <span style="font-size:0.8rem;color:#6b7280;" id="tagCloudCount">0 tags</span>
      </div>
      <div class="panel-body">
        <div class="tag-cloud" id="tagCloud">
          <div style="text-align:center;color:#9ca3af;padding:2rem;width:100%;">Loading tags...</div>
        </div>
      </div>
    </div>

    <!-- Recent Items Panel -->
    <div class="panel">
      <div class="panel-header">
        <h3>üìã Recent Nuggets</h3>
      </div>
      <div class="panel-body">
        <div class="recent-list" id="recentList">
          <div style="text-align:center;color:#9ca3af;padding:2rem;">Loading...</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- D3.js for visualization -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
let mindmapData = null;
let svg = null;
let g = null;
let zoom = null;
let currentView = 'force';
let simulation = null;

const LEVEL_COLORS = {
  'root': '#667eea',
  'data': '#3b82f6',
  'information': '#f59e0b',
  'knowledge': '#10b981',
  'wisdom': '#8b5cf6',
  'tag': '#ec4899'
};

// Initialize
document.addEventListener('DOMContentLoaded', async () => {
  // Always try to load panels (they use different endpoints)
  loadTagCloud();
  loadRecentItems();
  loadLastSyncInfo();
  loadMindmapSynthesis();  // Load AI synthesis
  
  // Load mindmap data
  const data = await loadMindmapData();
  if (data) {
    initMindmap();
  } else {
    // Show auth message in mindmap area
    const container = document.getElementById('mindmapCanvas');
    if (container) {
      container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:1.1rem;">Please refresh and log in to view the mindmap</div>';
    }
  }
});

// Load mindmap data from API
async function loadMindmapData() {
  try {
    const response = await fetch('/api/mindmap/data', { credentials: 'same-origin' });
    
    if (response.status === 401) {
      console.error('Session expired');
      showToast('‚ö†Ô∏è Session expired - please refresh and log in again', true);
      return null;
    }
    
    if (response.ok) {
      mindmapData = await response.json();
      console.log('Loaded mindmap data:', mindmapData.counts, 'nodes:', mindmapData.nodes?.length, 'tree children:', mindmapData.tree?.children?.length);
      updateStats(mindmapData);
      return mindmapData;
    } else {
      console.error('Failed to load mindmap data, status:', response.status);
      return null;
    }
  } catch (err) {
    console.error('Failed to load mindmap data:', err);
    return null;
  }
}

function updateStats(data) {
  document.getElementById('dataCount').textContent = data.counts?.data || 0;
  document.getElementById('informationCount').textContent = data.counts?.information || 0;
  document.getElementById('knowledgeCount').textContent = data.counts?.knowledge || 0;
  document.getElementById('wisdomCount').textContent = data.counts?.wisdom || 0;
  document.getElementById('tagCount').textContent = data.counts?.tags || 0;
  document.getElementById('connectionCount').textContent = data.counts?.connections || 0;
}

// Initialize D3 mindmap
function initMindmap() {
  const container = document.getElementById('mindmapCanvas');
  if (!container) {
    console.error('mindmapCanvas container not found');
    return;
  }
  
  const width = container.clientWidth || 800;
  const height = container.clientHeight || 550;
  
  console.log('initMindmap called, view:', currentView, 'width:', width, 'data:', mindmapData?.nodes?.length, 'items');
  
  // Clear existing
  container.innerHTML = '';
  if (simulation) simulation.stop();
  
  // Create SVG
  svg = d3.select('#mindmapCanvas')
    .append('svg')
    .attr('width', '100%')
    .attr('height', height)
    .attr('viewBox', `0 0 ${width} ${height}`);
  
  // Add zoom behavior
  zoom = d3.zoom()
    .scaleExtent([0.2, 4])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });
  
  svg.call(zoom);
  
  // Create main group for transformations
  g = svg.append('g')
    .attr('transform', `translate(${width/2}, ${height/2})`);
  
  // Check if we have data to render
  const hasItems = mindmapData && mindmapData.nodes && mindmapData.nodes.some(n => n.type === 'item');
  const hasTree = mindmapData && mindmapData.tree && mindmapData.tree.children && 
                  mindmapData.tree.children.some(c => c.children && c.children.length > 0);
  
  console.log('hasItems:', hasItems, 'hasTree:', hasTree);
  
  if (hasItems || hasTree) {
    renderMindmap();
  } else {
    g.append('text')
      .attr('text-anchor', 'middle')
      .attr('fill', '#9ca3af')
      .text('No data yet. Click "Regenerate Full Map" to generate the mindmap.');
  }
}

function renderMindmap() {
  if (!mindmapData) {
    console.error('renderMindmap called but no mindmapData');
    return;
  }
  
  const container = document.getElementById('mindmapCanvas');
  const width = container.clientWidth || 800;
  const height = container.clientHeight || 550;
  
  console.log('renderMindmap:', currentView, 'width:', width, 'height:', height);
  
  // Clear previous rendering
  g.selectAll('*').remove();
  if (simulation) simulation.stop();
  
  if (currentView === 'radial') {
    renderRadialTree(width, height);
  } else if (currentView === 'force') {
    renderForceGraph(width, height);
  } else {
    renderClusterView(width, height);
  }
}

function renderRadialTree(width, height) {
  if (!mindmapData.tree) {
    console.error('renderRadialTree: no tree data');
    return;
  }
  
  console.log('renderRadialTree: tree has', mindmapData.tree.children?.length, 'children');
  
  const radius = Math.min(width, height) / 2 - 80;
  const root = d3.hierarchy(mindmapData.tree);
  
  console.log('renderRadialTree: hierarchy has', root.descendants().length, 'total nodes');
  
  // Create radial tree layout
  const tree = d3.tree()
    .size([2 * Math.PI, radius])
    .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
  
  tree(root);
  
  // Draw links
  g.selectAll('.link')
    .data(root.links())
    .join('path')
    .attr('class', 'link')
    .attr('fill', 'none')
    .attr('stroke', '#d1d5db')
    .attr('stroke-width', 1.5)
    .attr('d', d3.linkRadial()
      .angle(d => d.x)
      .radius(d => d.y));
  
  // Draw nodes
  const nodes = g.selectAll('.node')
    .data(root.descendants())
    .join('g')
    .attr('class', 'node')
    .attr('transform', d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y}, 0)`)
    .style('cursor', 'pointer')
    .on('click', (event, d) => handleNodeClick(d))
    .on('mouseover', (event, d) => showTooltip(event, d.data))
    .on('mouseout', hideTooltip);
  
  nodes.append('circle')
    .attr('r', d => d.depth === 0 ? 18 : (d.data.type === 'tag' ? 5 : 8))
    .attr('fill', d => LEVEL_COLORS[d.data.level || d.data.type] || '#6b7280')
    .attr('stroke', 'white')
    .attr('stroke-width', 2);
  
  nodes.append('text')
    .attr('dy', '0.31em')
    .attr('x', d => d.x < Math.PI === !d.children ? 8 : -8)
    .attr('text-anchor', d => d.x < Math.PI === !d.children ? 'start' : 'end')
    .attr('transform', d => d.x >= Math.PI ? 'rotate(180)' : null)
    .attr('font-size', d => d.depth === 0 ? '12px' : '10px')
    .attr('fill', '#374151')
    .text(d => truncateText(d.data.name, 20));
}

function renderForceGraph(width, height) {
  if (!mindmapData.nodes || !mindmapData.links) {
    console.error('renderForceGraph: no nodes or links data');
    return;
  }
  
  console.log('renderForceGraph:', mindmapData.nodes.length, 'nodes,', mindmapData.links.length, 'links');
  
  // Reset transform for force layout
  g.attr('transform', null);
  
  const nodes = mindmapData.nodes.map(d => ({...d}));
  const links = mindmapData.links.map(d => ({...d}));
  
  simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(80))
    .force('charge', d3.forceManyBody().strength(-200))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(30));
  
  // Draw links
  const link = g.selectAll('.link')
    .data(links)
    .join('line')
    .attr('class', 'link')
    .attr('stroke', '#d1d5db')
    .attr('stroke-width', 1.5);
  
  // Draw nodes
  const node = g.selectAll('.node')
    .data(nodes)
    .join('g')
    .attr('class', 'node')
    .style('cursor', 'pointer')
    .on('click', (event, d) => handleNodeClick({ data: d }))
    .on('mouseover', (event, d) => showTooltip(event, d))
    .on('mouseout', hideTooltip)
    .call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended));
  
  node.append('circle')
    .attr('r', d => d.type === 'root' ? 18 : (d.type === 'tag' ? 6 : 10))
    .attr('fill', d => LEVEL_COLORS[d.level || d.type] || '#6b7280')
    .attr('stroke', 'white')
    .attr('stroke-width', 2);
  
  node.append('text')
    .attr('dy', -12)
    .attr('text-anchor', 'middle')
    .attr('font-size', '10px')
    .attr('fill', '#374151')
    .text(d => truncateText(d.name, 15));
  
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    
    node.attr('transform', d => `translate(${d.x}, ${d.y})`);
  });
  
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }
  
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }
}

function renderClusterView(width, height) {
  if (!mindmapData.tagClusters) {
    console.error('renderClusterView: no tagClusters data');
    return;
  }
  
  console.log('renderClusterView:', Object.keys(mindmapData.tagClusters).length, 'tag clusters');
  
  // Reset transform
  g.attr('transform', `translate(${width/2}, ${height/2})`);
  
  const clusters = Object.entries(mindmapData.tagClusters).map(([tag, items]) => ({
    name: tag,
    type: 'tag',
    count: items.length
  }));
  
  if (clusters.length === 0) {
    g.append('text')
      .attr('text-anchor', 'middle')
      .attr('fill', '#9ca3af')
      .text('No tags found. Add tags to your nuggets to see clusters.');
    return;
  }
  
  simulation = d3.forceSimulation(clusters)
    .force('charge', d3.forceManyBody().strength(-150))
    .force('center', d3.forceCenter(0, 0))
    .force('collision', d3.forceCollide().radius(d => 25 + d.count * 4));
  
  const nodes = g.selectAll('.tag-cluster')
    .data(clusters)
    .join('g')
    .attr('class', 'tag-cluster')
    .style('cursor', 'pointer')
    .on('mouseover', (event, d) => showTooltip(event, { name: d.name, level: 'tag', summary: `${d.count} items` }))
    .on('mouseout', hideTooltip);
  
  nodes.append('circle')
    .attr('r', d => 20 + d.count * 4)
    .attr('fill', LEVEL_COLORS.tag)
    .attr('opacity', 0.7)
    .attr('stroke', 'white')
    .attr('stroke-width', 2);
  
  nodes.append('text')
    .attr('text-anchor', 'middle')
    .attr('dy', '0.31em')
    .attr('font-size', '11px')
    .attr('fill', 'white')
    .attr('font-weight', '600')
    .text(d => truncateText(d.name, 12));
  
  simulation.on('tick', () => {
    nodes.attr('transform', d => `translate(${d.x}, ${d.y})`);
  });
}

function truncateText(text, maxLength) {
  if (!text) return '';
  return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

function handleNodeClick(d) {
  if (d.data && d.data.id) {
    window.location.href = `/dikw`;
  }
}

let tooltip = null;
function showTooltip(event, data) {
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.className = 'node-tooltip';
    document.body.appendChild(tooltip);
  }
  
  tooltip.innerHTML = `
    <div class="node-tooltip-title">${escapeHtml(data.name || 'Unknown')}</div>
    <div class="node-tooltip-level">${data.level || data.type || ''}</div>
    ${data.summary ? `<div style="margin-top:0.5rem;font-size:0.8rem;color:#6b7280;">${escapeHtml(truncateText(data.summary, 100))}</div>` : ''}
  `;
  
  tooltip.style.display = 'block';
  tooltip.style.left = (event.pageX + 10) + 'px';
  tooltip.style.top = (event.pageY + 10) + 'px';
}

function hideTooltip() {
  if (tooltip) {
    tooltip.style.display = 'none';
  }
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text || '';
  return div.innerHTML;
}

function changeView() {
  currentView = document.getElementById('viewMode').value;
  initMindmap();
}

function zoomIn() {
  svg.transition().call(zoom.scaleBy, 1.3);
}

function zoomOut() {
  svg.transition().call(zoom.scaleBy, 0.7);
}

function resetZoom() {
  const container = document.getElementById('mindmapCanvas');
  const width = container.clientWidth;
  const height = container.clientHeight || 550;
  svg.transition().call(zoom.transform, d3.zoomIdentity.translate(width/2, height/2));
}

// Regenerate full mindmap
async function regenerateMindmap() {
  const btn = document.getElementById('regenerateBtn');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Generating...';
  
  try {
    const response = await fetch('/api/mindmap/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ full: true })
    });
    
    if (response.status === 401) {
      showToast('‚ö†Ô∏è Session expired - please refresh and log in again', true);
      return;
    }
    
    if (response.ok) {
      const result = await response.json();
      console.log('Regenerate result:', result);
      const data = await loadMindmapData();
      if (data) {
        initMindmap();
        await loadTagCloud();
        loadLastSyncInfo();
        loadRecentItems();
        showToast(`Mindmap regenerated with ${result.total_items || 0} items!`);
      }
    } else {
      const err = await response.json();
      showToast('Failed to regenerate: ' + (err.error || 'Unknown error'), true);
    }
  } catch (err) {
    console.error('Regenerate error:', err);
    showToast('Failed to regenerate mindmap', true);
  } finally {
    btn.disabled = false;
    btn.innerHTML = 'üîÑ Regenerate Full Map';
  }
}

// Update with new items only
async function updateMindmap() {
  const btn = document.getElementById('updateBtn');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner dark"></span> Updating...';
  
  try {
    const response = await fetch('/api/mindmap/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ full: false })
    });
    
    if (response.status === 401) {
      showToast('‚ö†Ô∏è Session expired - please refresh and log in again', true);
      return;
    }
    
    if (response.ok) {
      const result = await response.json();
      console.log('Update result:', result);
      const data = await loadMindmapData();
      if (data) {
        initMindmap();
        await loadTagCloud();
        loadLastSyncInfo();
        loadRecentItems();
        showToast(`Updated! ${result.new_items || 0} new items (${result.total_items || 0} total)`);
      }
    } else {
      const err = await response.json();
      showToast('Failed to update: ' + (err.error || 'Unknown error'), true);
    }
  } catch (err) {
    console.error('Update error:', err);
    showToast('Failed to update mindmap', true);
  } finally {
    btn.disabled = false;
    btn.innerHTML = '‚ûï Update New Items';
  }
}

// Load tag cloud
async function loadTagCloud() {
  const cloud = document.getElementById('tagCloud');
  try {
    const response = await fetch('/api/mindmap/tags', { credentials: 'same-origin' });
    if (response.status === 401) {
      cloud.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;width:100%;">Session expired - please refresh</div>';
      return;
    }
    if (response.ok) {
      const tags = await response.json();
      document.getElementById('tagCloudCount').textContent = `${tags.length} tags`;
      
      if (tags.length > 0) {
        cloud.innerHTML = tags.slice(0, 50).map(tag => `
          <div class="tag-item" onclick="filterByTag('${escapeHtml(tag.name)}')">
            ${escapeHtml(tag.name)}<span class="tag-count">${tag.count}</span>
          </div>
        `).join('');
      } else {
        cloud.innerHTML = '<div style="text-align:center;color:#9ca3af;padding:1rem;width:100%;">No tags yet - generate items first</div>';
      }
    } else {
      console.error('Failed to load tags, status:', response.status);
      cloud.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;width:100%;">Failed to load tags</div>';
    }
  } catch (err) {
    console.error('Failed to load tag cloud:', err);
    cloud.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;width:100%;">Error loading tags</div>';
  }
}

// Load recent items
async function loadRecentItems() {
  const list = document.getElementById('recentList');
  try {
    const response = await fetch('/api/dikw', { credentials: 'same-origin' });
    if (response.status === 401) {
      list.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;">Session expired - please refresh</div>';
      return;
    }
    if (response.ok) {
      const data = await response.json();
      
      // Flatten pyramid into recent items
      const items = [];
      for (const level of ['wisdom', 'knowledge', 'information', 'data']) {
        for (const item of (data.pyramid?.[level] || []).slice(0, 3)) {
          items.push({ ...item, level });
        }
      }
      
      if (items.length > 0) {
        list.innerHTML = items.slice(0, 8).map(item => `
          <div class="recent-item ${item.level}" onclick="window.location.href='/dikw'">
            <div class="recent-item-level">${item.level}</div>
            <div class="recent-item-content">${escapeHtml(truncateText(item.content, 80))}</div>
          </div>
        `).join('');
      } else {
        list.innerHTML = '<div style="text-align:center;color:#9ca3af;padding:1rem;">No items yet - add items on the DIKW page</div>';
      }
    } else {
      console.error('Failed to load recent items, status:', response.status);
      list.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;">Failed to load items</div>';
    }
  } catch (err) {
    console.error('Failed to load recent items:', err);
    list.innerHTML = '<div style="text-align:center;color:#ef4444;padding:1rem;">Error loading items</div>';
  }
}

// Load last sync info
async function loadLastSyncInfo() {
  try {
    const response = await fetch('/api/mindmap/status', { credentials: 'same-origin' });
    if (response.ok) {
      const status = await response.json();
      const el = document.getElementById('lastSyncInfo');
      if (status.last_generated) {
        const date = new Date(status.last_generated);
        el.textContent = `Last updated: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
      }
    }
  } catch (err) {
    console.error('Failed to load sync info:', err);
  }
}

let activeTagFilter = null;
let originalMindmapData = null;

function filterByTag(tag) {
  if (!mindmapData) {
    showToast('No mindmap data loaded', true);
    return;
  }
  
  // Store original data if not already stored
  if (!originalMindmapData) {
    originalMindmapData = {
      nodes: JSON.parse(JSON.stringify(mindmapData.nodes)),
      links: JSON.parse(JSON.stringify(mindmapData.links)),
      tree: mindmapData.tree,
      tagClusters: mindmapData.tagClusters,
      counts: mindmapData.counts
    };
  }
  
  // Toggle filter - clear if same tag clicked
  if (activeTagFilter === tag) {
    activeTagFilter = null;
    // Remove all tag highlighting
    document.querySelectorAll('.tag-item').forEach(el => el.classList.remove('active'));
    // Restore original data
    mindmapData.nodes = originalMindmapData.nodes;
    mindmapData.links = originalMindmapData.links;
    showToast('Filter cleared - showing all items', false, 'info');
    renderMindmap();
    return;
  }
  
  // Update tag cloud highlighting - clear all first, then highlight selected
  document.querySelectorAll('.tag-item').forEach(el => el.classList.remove('active'));
  const tagItems = document.querySelectorAll('.tag-item');
  tagItems.forEach(el => {
    if (el.textContent.includes(tag)) {
      el.classList.add('active');
    }
  });
  
  // Restore original before applying new filter
  mindmapData.nodes = JSON.parse(JSON.stringify(originalMindmapData.nodes));
  mindmapData.links = JSON.parse(JSON.stringify(originalMindmapData.links));
  
  activeTagFilter = tag;
  const tagLower = tag.toLowerCase();
  
  // Check if tag exists in tagClusters
  if (!mindmapData.tagClusters || !mindmapData.tagClusters[tagLower]) {
    showToast(`No items found with tag: ${tag}`, true);
    return;
  }
  
  // Get IDs of items with this tag
  const taggedItemIds = new Set(mindmapData.tagClusters[tagLower].map(item => `item_${item.id}`));
  
  // Filter nodes to only show items with this tag (plus root and level nodes)
  const filteredNodes = mindmapData.nodes.filter(n => {
    if (n.type === 'root' || n.type === 'level') return true;
    return taggedItemIds.has(n.id);
  });
  
  // Count filtered items
  const itemCount = filteredNodes.filter(n => n.type === 'item').length;
  
  if (itemCount === 0) {
    showToast(`No items found with tag: ${tag}`, true);
    return;
  }
  
  // Filter links to only include filtered nodes
  const nodeIds = new Set(filteredNodes.map(n => n.id));
  const filteredLinks = mindmapData.links.filter(l => {
    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
    return nodeIds.has(sourceId) && nodeIds.has(targetId);
  });
  
  // Update mindmap data
  mindmapData.nodes = filteredNodes;
  mindmapData.links = filteredLinks;
  
  showToast(`Filtering by "${tag}": ${itemCount} items`, false, 'info');
  renderMindmap();
}

function showToast(message, isError = false, type = null) {
  const toast = document.createElement('div');
  toast.className = `graph-toast ${isError ? 'error' : ''} ${type || ''}`;
  toast.innerHTML = `${isError ? '‚ùå' : '‚úÖ'} ${message}`;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    toast.style.transition = 'all 0.3s';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Load mindmap synthesis (AI-generated knowledge summary)
async function loadMindmapSynthesis() {
  const section = document.getElementById('mindmapSynthesisSection');
  const content = document.getElementById('mindmapSynthesisContent');
  
  if (!section || !content) return;
  
  try {
    const response = await fetch('/api/mindmap/synthesis', { credentials: 'same-origin' });
    
    if (response.status === 401) {
      content.innerHTML = '<p style="color: #ef4444; text-align: center; padding: 1rem;">Session expired - please refresh</p>';
      return;
    }
    
    if (response.status === 404) {
      // No synthesis yet - show generation button
      section.style.display = 'block';
      content.innerHTML = `
        <div style="text-align: center; padding: 2rem;">
          <p style="color: #6b7280; margin-bottom: 1rem;">No synthesis generated yet.</p>
          <button class="graph-btn graph-btn-primary" onclick="generateSynthesis()" id="generateSynthesisBtn">
            ‚ú® Generate Knowledge Synthesis
          </button>
          <p style="font-size: 0.75rem; color: #9ca3af; margin-top: 0.75rem;">Uses AI to synthesize all mindmaps into a unified knowledge structure.</p>
        </div>
      `;
      return;
    }
    
    if (response.ok) {
      const data = await response.json();
      if (data.success && data.synthesis) {
        section.style.display = 'block';
        const synthesis = data.synthesis;
        const keyTopics = synthesis.key_topics || [];
        const synthesisText = synthesis.synthesis_text || 'No synthesis available.';
        const createdAt = synthesis.created_at ? new Date(synthesis.created_at).toLocaleString() : '';
        
        content.innerHTML = `
          <div style="margin-bottom: 1rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
              <span style="font-size: 0.75rem; color: #6b7280;">Generated: ${createdAt}</span>
              <button class="graph-btn graph-btn-secondary" onclick="generateSynthesis()" id="regenerateSynthesisBtn" style="font-size: 0.75rem; padding: 0.3rem 0.6rem;">
                üîÑ Regenerate
              </button>
            </div>
            ${keyTopics.length > 0 ? `
              <div style="margin-bottom: 1rem;">
                <strong style="font-size: 0.85rem; color: #374151;">Key Topics:</strong>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                  ${keyTopics.slice(0, 10).map(t => `<span style="background: #e0e7ff; color: #4338ca; padding: 0.25rem 0.5rem; border-radius: 1rem; font-size: 0.75rem;">${escapeHtml(t)}</span>`).join('')}
                </div>
              </div>
            ` : ''}
            <div style="font-size: 0.9rem; color: #374151; line-height: 1.6; white-space: pre-wrap;">${escapeHtml(synthesisText)}</div>
          </div>
        `;
      }
    }
  } catch (err) {
    console.error('Failed to load synthesis:', err);
    content.innerHTML = '<p style="color: #ef4444; text-align: center; padding: 1rem;">Error loading synthesis</p>';
  }
}

// Generate new synthesis
async function generateSynthesis() {
  const btn = document.getElementById('generateSynthesisBtn') || document.getElementById('regenerateSynthesisBtn');
  if (btn) {
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span> Generating...';
  }
  
  try {
    const response = await fetch('/api/mindmap/synthesize?force=true', {
      method: 'POST',
      credentials: 'same-origin',
    });
    
    if (response.ok) {
      showToast('Synthesis generated successfully!');
      await loadMindmapSynthesis();  // Reload
    } else {
      const err = await response.json();
      showToast('Failed to generate synthesis: ' + (err.error || 'Unknown error'), true);
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = '‚ú® Generate Knowledge Synthesis';
      }
    }
  } catch (err) {
    console.error('Failed to generate synthesis:', err);
    showToast('Failed to generate synthesis', true);
    if (btn) {
      btn.disabled = false;
      btn.innerHTML = '‚ú® Generate Knowledge Synthesis';
    }
  }
}

function toggleSynthesisDetail() {
  const content = document.getElementById('mindmapSynthesisContent');
  if (content) {
    content.style.display = content.style.display === 'none' ? 'block' : 'none';
  }
}
</script>
{% endblock %}
