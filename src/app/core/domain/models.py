# src/app/core/domain/models.py
"""
Domain Models - Pure dataclasses representing business entities.

All models use:
- Optional[str] for IDs (UUIDs stored as strings, auto-generated by DB)
- Optional for nullable fields
- datetime for timestamps
- Enum subclasses for type-safe choices
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from enum import Enum


# =============================================================================
# ENUMS
# =============================================================================

class DIKWLevel(str, Enum):
    """DIKW pyramid levels for knowledge organization."""
    DATA = "data"
    INFORMATION = "information"
    KNOWLEDGE = "knowledge"
    WISDOM = "wisdom"


class SignalType(str, Enum):
    """Types of signals extracted from content."""
    DECISION = "decision"
    ACTION_ITEM = "action_item"
    BLOCKER = "blocker"
    RISK = "risk"
    IDEA = "idea"
    INSIGHT = "insight"
    QUESTION = "question"
    FOLLOW_UP = "follow_up"


class TicketStatus(str, Enum):
    """Ticket workflow statuses."""
    BACKLOG = "backlog"
    READY = "ready"
    IN_PROGRESS = "in_progress"
    BLOCKED = "blocked"
    IN_REVIEW = "in_review"
    DONE = "done"


class NotificationType(str, Enum):
    """Types of notifications."""
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    TASK = "task"
    REMINDER = "reminder"


class SuggestionType(str, Enum):
    """Types of career suggestions."""
    SKILL_DEVELOPMENT = "skill_development"
    PROJECT_IDEA = "project_idea"
    LEARNING_PATH = "learning_path"
    NETWORKING = "networking"
    CERTIFICATION = "certification"
    PROCESS_IMPROVEMENT = "process_improvement"
    VISIBILITY = "visibility"


class SuggestionStatus(str, Enum):
    """Status of career suggestions."""
    SUGGESTED = "suggested"
    ACCEPTED = "accepted"
    DISMISSED = "dismissed"
    COMPLETED = "completed"
    CONVERTED = "converted"


class MemoryType(str, Enum):
    """Types of career memories."""
    PROJECT = "project"
    ACHIEVEMENT = "achievement"
    LEARNING = "learning"
    FEEDBACK = "feedback"
    MILESTONE = "milestone"
    CONTRIBUTION = "contribution"


# =============================================================================
# MEETING DOMAIN
# =============================================================================

@dataclass
class Signal:
    """Signal extracted from meeting content."""
    id: Optional[str] = None
    meeting_id: Optional[str] = None
    signal_type: SignalType = SignalType.DECISION
    signal_text: str = ""
    feedback: Optional[str] = None
    status: Optional[str] = None
    converted_to: Optional[str] = None
    converted_id: Optional[str] = None
    confidence: Optional[float] = None
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'signal_type' in d and isinstance(d['signal_type'], SignalType):
            d['signal_type'] = d['signal_type'].value
        return d


@dataclass
class Meeting:
    """Meeting entity with extracted signals and metadata."""
    id: Optional[str] = None
    meeting_name: str = ""
    meeting_date: Optional[str] = None
    
    # Content
    transcript: Optional[str] = None
    summary: Optional[str] = None
    topics: Optional[str] = None
    attendees: Optional[str] = None
    
    # Signals (stored as JSON)
    signals: Optional[Dict[str, List[str]]] = None
    
    # Pocket integration
    pocket_recording_id: Optional[str] = None
    pocket_transcript: Optional[str] = None
    pocket_ai_summary: Optional[str] = None
    pocket_mind_map: Optional[str] = None
    pocket_template_type: Optional[str] = None
    
    # Teams integration
    teams_transcript: Optional[str] = None
    
    # Processing state
    import_source: Optional[str] = None
    processed: bool = False
    embedding_id: Optional[str] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Meeting":
        """Factory method to create Meeting from dict."""
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})


@dataclass
class MeetingBundle:
    """Bundle of meeting content from multiple sources."""
    meeting_name: str
    meeting_date: str
    
    # Transcripts from different sources
    teams_transcript: Optional[str] = None
    pocket_transcript: Optional[str] = None
    
    # Pocket-specific content
    pocket_recording_id: Optional[str] = None
    pocket_ai_summary: Optional[str] = None
    pocket_mind_map: Optional[str] = None
    pocket_template_type: Optional[str] = None
    
    # Import metadata
    import_source: str = "manual"
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


# =============================================================================
# DOCUMENT DOMAIN
# =============================================================================

@dataclass
class Document:
    """Document entity (transcripts, notes, attachments)."""
    id: Optional[str] = None
    source: str = ""
    content: str = ""
    document_type: str = "transcript"
    
    # Relationships
    meeting_id: Optional[str] = None
    
    # Processing
    processed: bool = False
    embedding_id: Optional[str] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


# =============================================================================
# TICKET DOMAIN
# =============================================================================

@dataclass
class Ticket:
    """Ticket/task entity."""
    id: Optional[str] = None
    ticket_id: str = ""
    title: str = ""
    description: Optional[str] = None
    status: TicketStatus = TicketStatus.BACKLOG
    priority: str = "medium"
    
    # Relationships
    meeting_id: Optional[str] = None
    source_signal: Optional[str] = None
    parent_ticket_id: Optional[str] = None
    
    # Metadata
    tags: Optional[List[str]] = None
    estimated_hours: Optional[float] = None
    actual_hours: Optional[float] = None
    
    # Timestamps
    due_date: Optional[date] = None
    completed_at: Optional[datetime] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'status' in d and isinstance(d['status'], TicketStatus):
            d['status'] = d['status'].value
        return d


@dataclass
class TaskDecomposition:
    """AI-generated task decomposition for a ticket."""
    id: Optional[str] = None
    ticket_id: str = ""
    
    # Decomposition content
    subtasks: List[Dict[str, Any]] = field(default_factory=list)
    context_summary: Optional[str] = None
    suggested_approach: Optional[str] = None
    
    # AI metadata
    model_used: Optional[str] = None
    confidence: Optional[float] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


# =============================================================================
# DIKW DOMAIN
# =============================================================================

@dataclass
class DIKWItem:
    """DIKW pyramid item for knowledge organization."""
    id: Optional[str] = None
    level: DIKWLevel = DIKWLevel.DATA
    content: str = ""
    summary: Optional[str] = None
    
    # Source tracking
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    meeting_id: Optional[str] = None
    original_signal_type: Optional[str] = None
    
    # Classification
    tags: Optional[List[str]] = None
    
    # Confidence and validation
    confidence: int = 70
    validation_count: int = 0
    status: str = "active"
    
    # Promotion tracking
    promoted_to: Optional[str] = None
    promoted_at: Optional[datetime] = None
    source_ref_ids: Optional[List[str]] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'level' in d and isinstance(d['level'], DIKWLevel):
            d['level'] = d['level'].value
        return d
    
    def can_promote(self) -> bool:
        """Check if item can be promoted to next level."""
        if self.level == DIKWLevel.WISDOM:
            return False
        return self.confidence >= 80 and self.validation_count >= 2


# =============================================================================
# CONVERSATION DOMAIN
# =============================================================================

@dataclass
class Conversation:
    """Chat conversation entity."""
    id: Optional[str] = None
    title: Optional[str] = None
    
    # Context
    meeting_id: Optional[str] = None
    document_id: Optional[str] = None
    summary: Optional[str] = None
    
    # State
    archived: bool = False
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


@dataclass
class Message:
    """Chat message entity."""
    id: Optional[str] = None
    conversation_id: str = ""
    role: str = "user"  # user, assistant, system
    content: str = ""
    
    # LangSmith tracking
    run_id: Optional[str] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


# =============================================================================
# CAREER DOMAIN
# =============================================================================

@dataclass
class CareerProfile:
    """User's career profile (singleton per user)."""
    id: int = 1  # Always 1 (single profile)
    
    # Current state
    current_role: str = ""
    target_role: Optional[str] = None
    years_experience: Optional[int] = None
    
    # Skills and traits
    strengths: Optional[str] = None
    weaknesses: Optional[str] = None
    interests: Optional[str] = None
    technical_specializations: Optional[str] = None
    soft_skills: Optional[str] = None
    
    # Goals
    goals: Optional[str] = None
    short_term_goals: Optional[str] = None
    long_term_goals: Optional[str] = None
    learning_priorities: Optional[str] = None
    
    # Background
    certifications: Optional[str] = None
    education: Optional[str] = None
    notable_projects: Optional[str] = None
    work_achievements: Optional[str] = None
    
    # Preferences
    preferred_work_style: Optional[str] = None
    industry_focus: Optional[str] = None
    career_values: Optional[str] = None
    
    # Experience
    leadership_experience: Optional[str] = None
    mentorship: Optional[str] = None
    networking: Optional[str] = None
    
    # Other
    languages: Optional[str] = None
    career_timeline: Optional[str] = None
    
    # Timestamps
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


@dataclass
class CareerSuggestion:
    """AI-generated career suggestion."""
    id: Optional[str] = None
    suggestion_type: SuggestionType = SuggestionType.SKILL_DEVELOPMENT
    title: str = ""
    description: str = ""
    
    # Details
    rationale: Optional[str] = None
    difficulty: Optional[str] = None
    time_estimate: Optional[str] = None
    related_goal: Optional[str] = None
    
    # State
    status: SuggestionStatus = SuggestionStatus.SUGGESTED
    converted_to_ticket: Optional[str] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'suggestion_type' in d and isinstance(d['suggestion_type'], SuggestionType):
            d['suggestion_type'] = d['suggestion_type'].value
        if 'status' in d and isinstance(d['status'], SuggestionStatus):
            d['status'] = d['status'].value
        return d


@dataclass
class CareerMemory:
    """Career-related memory for context and learning."""
    id: Optional[str] = None
    memory_type: MemoryType = MemoryType.PROJECT
    title: str = ""
    description: Optional[str] = None
    
    # Source tracking
    source_type: Optional[str] = None
    source_id: Optional[str] = None
    
    # Content
    skills: Optional[List[str]] = None
    technologies: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = None
    
    # Flags
    is_pinned: bool = False
    is_ai_work: bool = False
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'memory_type' in d and isinstance(d['memory_type'], MemoryType):
            d['memory_type'] = d['memory_type'].value
        return d


@dataclass
class StandupUpdate:
    """Daily standup update with analysis."""
    id: Optional[str] = None
    standup_date: date = field(default_factory=date.today)
    content: str = ""
    
    # AI analysis
    feedback: Optional[str] = None
    sentiment: Optional[str] = None
    key_themes: Optional[List[str]] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'standup_date' in d and isinstance(d['standup_date'], date):
            d['standup_date'] = d['standup_date'].isoformat()
        return d


@dataclass
class Skill:
    """Tracked skill with proficiency metrics."""
    id: Optional[str] = None
    skill_name: str = ""
    category: Optional[str] = None
    
    # Proficiency
    proficiency_level: int = 0  # 0-100
    
    # Usage metrics
    tickets_count: int = 0
    projects_count: int = 0
    last_used_at: Optional[datetime] = None
    
    # Evidence
    evidence: Optional[List[Dict[str, Any]]] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


# =============================================================================
# SYSTEM DOMAIN
# =============================================================================

@dataclass
class Notification:
    """User notification entity."""
    id: Optional[str] = None
    title: str = ""
    message: str = ""
    notification_type: NotificationType = NotificationType.INFO
    
    # Navigation
    link: Optional[str] = None
    
    # State
    read: bool = False
    dismissed: bool = False
    
    # Timestamps
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        d = {k: v for k, v in self.__dict__.items() if v is not None}
        if 'notification_type' in d and isinstance(d['notification_type'], NotificationType):
            d['notification_type'] = d['notification_type'].value
        return d


@dataclass
class UserStatus:
    """User status/presence."""
    id: Optional[str] = None
    user_id: str = "default"
    status: str = "available"
    
    # Context
    current_task: Optional[str] = None
    mode_session_id: Optional[str] = None
    
    # Timestamps
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


@dataclass
class ModeSession:
    """Workflow mode session tracking."""
    id: Optional[str] = None
    mode: str = "mode-a"
    
    # Timing
    started_at: Optional[datetime] = None
    ended_at: Optional[datetime] = None
    duration_minutes: Optional[int] = None
    
    # Timestamps
    created_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}


@dataclass
class Settings:
    """Application settings (key-value store)."""
    key: str
    value: Any
    updated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {k: v for k, v in self.__dict__.items() if v is not None}
